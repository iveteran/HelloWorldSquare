# vim:ft=lf
# lf/commands.conf
# @author nate zhou
# since 2025

cmd on-cd &{{
    bash -c '
    # display git repository status in your prompt
    source /usr/share/git/completion/git-prompt.sh

    GIT_PS1_SHOWDIRTYSTATE=1        # + for staged, * if unstaged
    GIT_PS1_SHOWSTASHSTATE=1        # $ if something is stashed.
    GIT_PS1_SHOWUNTRACKEDFILES=1    # % if there are untracked files
    GIT_PS1_SHOWUPSTREAM=1 	        # <, >, <> behind, ahead, or diverged from upstream.
    GIT_PS1_STATESEPARATOR=" " 	    # separator between branch name and state symbols
    GIT_PS1_DESCRIBE_STYLE=1 	    # show commit relative to tag or branch, when detached HEAD
    GIT_PS1_SHOWCOLORHINTS=1        # display in color

    git=$(__git_ps1 " %s")
    fmt="\033[106m%u@%h\033[00m \033[01;40m%d%f$git\033[0m"
    lf -remote "send $id set promptfmt \"$fmt\""
    '
}}
on-cd

cmd on-redraw &{{
    if [ $lf_width -lt 60 ]; then
        # The order of `set preivew` and `set ratios` matters because:
        #   - `preview` is disabled if `ratios` is `1`
        #   - `set preview true` then fails
        lf -remote "send $id set preview false"
        lf -remote "send $id set ratios 1"
    elif [ $lf_width -lt 80 ]; then
        lf -remote "send $id set ratios 2:3"
        lf -remote "send $id set preview true"
    elif [ $lf_width -lt 120 ]; then
        lf -remote "send $id set ratios 1:2:3"
        lf -remote "send $id set preview true"
    elif [ $lf_width -lt 160 ]; then
        lf -remote "send $id set ratios 1:3:4"
        lf -remote "send $id set preview true"
    fi
}}

cmd toggle-preview %{{
    if [ "$lf_preview" = true ]; then
        lf -remote "send $id :set preview false; set ratios 1:5; set info size:time"
    else
        lf -remote "send $id :set preview true; set ratios 1:2:3"
    fi
}}

cmd fzf_jump ${{
    # `~/.local/bin/scope` checks `$FZF_LEVEL`
    res="$(find . | FZF_LEVEL=1 fzf --reverse --prompt "lf >" --preview '${HOME}/.local/bin/scope {}' --preview-window=75%:bottom:)"
    if [ -n "$res" ]; then
        if [ -d "$res" ]; then
            cmd="cd"
        else
            cmd="select"
        fi
        res="$(printf '%s' "$res" | sed 's/\\/\\\\/g;s/"/\\"/g')"
        lf -remote "send $id $cmd \"$res\""
    fi
}}
map F fzf_jump

cmd touch %{{
    IFS=" "
    file="$*"
    touch -- "$file"
    lf -remote "send $id select \"$(printf '%s' "$file" | sed 's/\\/\\\\/g;s/"/\\"/g')\""
}}
map o push :touch<space>

cmd mkdir %{{
    IFS=" "
    file="$*"
    mkdir -p -- "$file"
    lf -remote "send $id select \"$(printf '%s' "$file" | sed 's/\\/\\\\/g;s/"/\\"/g')\""
}}
map O push :mkdir<space>

cmd chmod %{{
    printf "chmod $fx "
	read perm
    [ -z "$perm" ] && return
    for f in $fx; do
        chmod "$perm" "$f"
    done
    lf -remote "send $id reload"
}}
map xm chmod

cmd chown %{{
    printf "chown $fx "
	read owner
    [ -z "$owner" ] && return
    for f in $fx; do
        chown "$owner" "$f"
    done
    lf -remote "send $id reload"
}}
map xo chown

# y (select for copy) and P to paste symlink
# d (select for cut) and P to paste hard link
cmd link %{{
    set -- $(cat ~/.local/share/lf/files)
    mode="$1"
    shift
    if [ "$#" -lt 1 ]; then
        lf -remote "send $id echoerr no files to link"
        exit
    fi
    case "$mode" in
        # 'copy' mode indicates a symlink
        copy) ln -sr -t . -- "$@";;
        # while 'move' mode indicates a hard link
        move)
            ln -t . -- "$@"
            lf -remote "send clear"
            ;;
    esac
}}
map P :link

cmd backup %{{
    set -- $(cat ~/.local/share/lf/files)
    mode="$1"
    shift
    if [ "$#" -lt 1 ]; then
        lf -remote "send $id echoerr no files to backup"
        exit
    fi
    case "$mode" in
        copy) ${HOME}/.local/bin/bk "$@";;
        move) ${HOME}/.local/bin/bk --in-place "$@";;
    esac
}}
map B :backup

cmd bulk-rename ${{
    old="$(mktemp)"
    new="$(mktemp)"
    if [ -n "$fs" ]; then
        fs="$(basename -a -- $fs)"
    else
        fs="$(ls)"
    fi
    printf '%s\n' "$fs" > "$old"
    printf '%s\n' "$fs" > "$new"
    $EDITOR "$new"
    [ "$(wc -l < "$new")" -ne "$(wc -l < "$old")" ] && exit
    paste "$old" "$new" | while IFS= read -r names; do
        src="$(printf '%s' "$names" | cut -f1)"
        dst="$(printf '%s' "$names" | cut -f2)"
        if [ "$src" = "$dst" ] || [ -e "$dst" ]; then
            continue
        fi
        mv -- "$src" "$dst"
    done
    rm -- "$old" "$new"
    lf -remote "send $id unselect"
}}
map xb bulk-rename

cmd lf-mirror &{{
    # sleep to avoid flickering
    footclient sh -c 'sleep 0.03 && lf'
}}
map zm lf-mirror
# <c-m> also sends 13 which is the ASCII value of \r
map <enter> lf-mirror

cmd extract %{{
    printf "extract file?(y/n)"
    read choice
    if [ "$choice" = "y" ]; then
        case "$f" in
        *.tar) tar xf "$f" ;;
        *.zip|*.apk) unzip "$f" -d "$(basename $f | sed -E 's/.apk$|.zip$//')" ;;
        *.7z) 7z x "$f" ;;
        *.tar.gz|*.tgz|*.taz) tar xzf "$f" ;;
        *.gz) gunzip -k "$f" ;;
        *.tar.bz2|*.tbz2|*.tbz|*.tz2|*.tb2) tar xjf "$f" ;;
        *.bz2) bzip2 -dk "$f" ;;
        *.tar.xz|*.txz) tar xJf "$f" ;;
        *.xz) xz -dk "$f" ;;
        *.tar.zst|*.tzst) tar xf "$f" --zstd ;;
        *.zst) zstd -dk "$f" ;;
        *.rar) unrar-free -x "$f" ;;
        esac
    fi
    lf -remote "send clear"
}}
map xx extract

cmd readlink-cd &{{
    # readlink instead of realpath so it only work with symlinks
    readlink=$(readlink $f)
    lf -remote "send $id cd $readlink"
}}
map ; readlink-cd

cmd execute !{{
    if [ -x $f ]; then
        sh -c $f
    else
        case "$(file -Lb --mime-type $f)" in
            text/x-java) java $f ;;
            text/x-makefile) make ;;
        esac
    fi
}}
map xX execute

cmd rotate %{{
    printf "rotate degree?: "
    read line
    convert -rotate "$line" "$f" "$f"
    lf -remote "send clear"
}}
map xr rotate

cmd id3v2Title %{{
    printf "mid3v2 -a "
	read title
    [ -z "$title" ] && return
    for f in $fx; do
        mid3v2 -a "$title" "$f"
    done
    lf -remote "send $id reload"
}}
map Tt id3v2Title

cmd id3v2Artist %{{
    printf "mid3v2 -a "
	read artist
    [ -z "$artist" ] && return
    for f in $fx; do
        mid3v2 -a "$artist" "$f"
    done
    lf -remote "send $id reload"
}}
map Ta id3v2Artist

cmd id3v2AlbumArtist %{{
    printf "mid3v2 -a "
	read tpe2
    [ -z "$tpe2" ] && return
    for f in $fx; do
        mid3v2 --TPE2 "$tpe2" "$f"
    done
    lf -remote "send $id reload"
}}
map T2 id3v2AlbumArtist

cmd id3v2Album %{{
    printf "mid3v2 -A "
	read album
    [ -z "$album" ] && return
    for f in $fx; do
        mid3v2 -A "$album" "$f"
    done
    lf -remote "send $id reload"
}}
map TA id3v2Album

cmd id3v2Year %{{
    printf "mid3v2 -y "
	read year
    [ -z "$year" ] && return
    for f in $fx; do
        mid3v2 -y "$year" "$f"
    done
    lf -remote "send $id reload"
}}
map Ty id3v2Year

cmd id3v2Track %{{
    printf "mid3v2 -T "
	read track
    [ -z "$track" ] && return
    for f in $fx; do
        mid3v2 -T "$track" "$f"
    done
    lf -remote "send $id reload"
}}
map TT id3v2Track

cmd gitBranch ${{
    git branch | fzf | xargs -I{} git checkout {}
    # invoke on-cd
    CWD=$(pwd)
    lf -remote "send $id updir"
    lf -rem4ote "send $id cd $CWD"
}}
map gb gitBranch
